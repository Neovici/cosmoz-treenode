<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../cosmoz-tree/cosmoz-tree.html">

<!--
`cosmoz-treenode` is a component to display a node in a `cosmoz-tree` data structure

@demo demo/index.html
-->
<dom-module id="cosmoz-treenode">
	<template>
		<style>
			#ellipsis {
				margin-right: 0.2em;
			}
			::slotted(.separator) {
                margin: 0 0.2em;
            }

			::slotted(.separator.separator.sep0) {
				display: none;
			}

			:slotted(.part) {
				white-space: nowrap;
			}
		</style>

		<span id="ellipsis" hidden$="[[ !hideFromRoot ]]">[[ ellipsis ]]</span>

		<template>
			<span class$="separator sep[[ index ]]">[[ pathSeparator ]]</span> <span class="part">[[ value ]]</span>
		</template>

		<slot></slot>

	</template>
	<script>
		Polymer({
			is: 'cosmoz-treenode',

			properties: {

				/**
				 * Name of the property used to lookup the displayed node in the tree
				 */
				keyProperty: {
					type: String,
				},

				/**
				 * The value for the `keyProperty` used to lookup the node in the tree.
				 */
				keyValue: {
					type: String
				},

				ownerTree: {
					type: Cosmoz.Tree
				},

				indexAs: {
					type: String,
					value: 'index'
				},

				nodeAs: {
					type: String,
					value: 'node'
				},

				valueAs: {
					type: String,
					value: 'value'
				},

				valueProperty: {
					type: String,
					value: 'name'
				},

				pathSeparator: {
					type: String,
					value: '/'
				},

				/**
				 * Represent a number of nodes that should not be rendered starting from root.
				 * If the path to the displayed node has less nodes than this number, then nothing is hidden.
				 */
				hideFromRoot: {
					type: Number,
					value: 0
				},

				ellipsis: {
					type: String,
					value: 'â€¦ /'
				},

				_path: {
					type: Array,
					computed: '_computePath(ownerTree, keyProperty, keyValue)'
				},

				_pathToRender: {
					type: Array,
					computed: '_computePathToRender(_path, hideFromRoot)'
				}
			},

			behaviors: [
				Polymer.Templatizer
			],

			observers: [
				'_renderNode(_pathToRender, pathSeparator)'
			],

			ready: function () {
				this._instanceProps = {};
				this._instanceProps[this.nodeAs] = true;
				this._instanceProps[this.indexAs] = true;
				this._instanceProps[this.valueAs] = true;
				this._templateInstances = [];
			},

			_computePathToRender: function (path, hideFromRoot) {
				if (hideFromRoot > 0 && path.length > hideFromRoot) {
					return path.slice(hideFromRoot);
				}
				return path;
			},

			_computePath: function (ownerTree, keyProperty, keyValue) {
				return ownerTree.getPathByProperty(keyProperty, keyValue);
			},

			_renderNode: function (pathToRender) {

				if (!pathToRender || !Array.isArray(pathToRender) || pathToRender.length === 0) {
					return;
				}

				var parent,
					instance,
					node,
					i;

				this._cleanPreviousRender();

				parent = Polymer.dom(this);
				this._ensureTemplatized();

				this.$.ellipsis.hidden = pathToRender.length === this._path.length;

				for (i = 0; i < pathToRender.length; i+=1) {
					node = pathToRender[i];
					instance = this.stamp();
					instance[this.nodeAs] = node;
					instance[this.indexAs] = i;
					instance[this.valueAs] = this.ownerTree.getProperty(node, this.valueProperty);
					this._templateInstances.push(instance);
					parent.appendChild(instance.root);
				}
			},

			_cleanPreviousRender: function () {
				var inst,
					i,
					j;

				if (this._templateInstances !== undefined && this._templateInstances.length > 0) {
					for (i = 0; i < this._templateInstances.length; i+=1) {
						inst = this._templateInstances[i];
						// TODO(pasleq): not safe to use Templatizer internal property, but seems children is not working on Safari
						// See Polymer.Templatizer source
						for (j = 0; j <inst._children.length; j+=1) {
							// Appending the child to instance instance's root will detach it from it's current location
							Polymer.dom(inst.root).appendChild(inst._children[j]);
						}
					}

					this._templateInstances.splice(0);
				}
			},

			_ensureTemplatized: function () {
				if (!this.ctor) {
					this._nodeTemplate = Polymer.dom(this).querySelector('template');
					if (this._nodeTemplate === null) {
						this._nodeTemplate = Polymer.dom(this.root).querySelector('template');
					}

					this.templatize(this._nodeTemplate);
				}
			},


			_forwardParentProp: function (prop, value) {
				if (this._templateInstances) {
					this._templateInstances.forEach(function (inst) {
						inst[prop] = value;
					}, this);
				}
			},

			_forwardParentPath: function (path, value) {
				if (this._templateInstances) {
					this._templateInstances.forEach(function (inst) {
						inst.notifyPath(path, value, true);
					});
				}
			}

		});
	</script>
</dom-module>
