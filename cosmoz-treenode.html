<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../cosmoz-tree/cosmoz-tree.html">

<!--
`cosmoz-treenode` is a component to display a node in a `cosmoz-tree` data structure

@demo demo/index.html
-->
<dom-module id="cosmoz-treenode">
	<template>
		<style>
			#ellipsis {
				margin-right: 0.2em;
			}
			.separator {
				margin: 0 0.2em;
			}
			.separator.sep0 {
				display: none;
			}
			.part {
				white-space: nowrap;
			}
		</style>

		<span id="ellipsis" hidden$="[[ !hideFromRoot ]]">[[ ellipsis ]]</span>
		
		<template is="dom-repeat" items="[[ pathToRender ]]" as="part">
			<span class$="separator sep[[ index ]]"> [[ pathSeparator ]]</span> <span class="part">[[ part.name ]]</span>
		</template>

		<slot></slot>
	</template>
	<script>
		Polymer({
			is: 'cosmoz-treenode',

			properties: {

				/**
				 * Generic way to hint about key type, or unknown if we should guess
				 */
				keyType: {
					type: String,
					value: 'unknown'
				},

				/**
				 * The value for the keyType (nodeId or pathLocator),
				 * will be reflected to the right property based on keyType
				 * value or guess
				 */
				keyId: {
					type: String
				},

				nodeId: {
					type: Object,
					value: null,
					observer: 'nodeIdChanged'
				},

				ownerTree: {
					type: Cosmoz.Tree
				},

				pathLocator: {
					type: String,
					value: null
				},

				pathSeparator: {
					type: String,
					value: '/'
				},

				/**
				 * Represent a number of nodes that should not be rendered starting from root.
				 * If the path to the displayed node has less nodes than this number, then nothing is hidden.
				 */
				hideFromRoot: {
					type: Number,
					value: 0
				},

				ellipsis: {
					type: String,
					value: 'â€¦ /'
				},

				pathToRender: {
					type: Array,
					computed: 'computePathToRender(_path, hideFromRoot)'
				},

				_path: {
					type: Array,
					computed: '_computePath(pathLocator, ownerTree)'
				}
			},

			observers: [
				'_setKey(keyType, keyId)'
			],

			computePathToRender: function (path, hideFromRoot) {
				if (!path || !Array.isArray(path) || path.length < 1) {
					return;
				}
				var pathOffset = this.pathLocator.split('.').length - path.length;
				return path.filter(function (part, index) {
					return index + pathOffset >= hideFromRoot;
				});
			},

			nodeIdChanged: function (newNodeId) {
				if (!newNodeId || !this.ownerTree) {
					return;
				}
				var node = this.ownerTree.findNodeById(newNodeId);
				if (!node || !node.pathLocator) {
					return;
				}
				this.set('pathLocator', node.pathLocator);
			},

			_setKey: function (keyType, keyId) {
				if (!keyType) {
					return;
				}
				if (keyType === 'unknown') {
					if (this.ownerTree.isGuid(keyId)) {
						keyType = 'nodeId';
					} else {
						keyType = 'pathLocator';
					}
				}
				this.set(keyType, keyId);
			},

			_computePath: function (pathLocator, ownerTree) {
				if (!pathLocator) {
					return;
				}
				return ownerTree.getPathByLocator(pathLocator);
			}
		});
	</script>
</dom-module>