<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

	<title>cosmoz-treenode test</title>

	<script src="/components/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
	<script src="/components/mocha/mocha.js"></script>
	<script src="/components/wct-mocha/wct-mocha.js"></script>
	<script src="/components/chai/chai.js"></script>
	<script src="/components/@polymer/test-fixture/test-fixture-mocha.js"></script>

	<script type="module" src="/components/@polymer/test-fixture/test-fixture.js"></script>
	<script type="module" src="/components/@polymer/iron-test-helpers/iron-test-helpers.js"></script>

	<script type="module" src="../cosmoz-treenode.js"></script>
</head>
<body>

	<test-fixture id="basic">
		<template>
			<cosmoz-treenode key-property="pathLocator" key-value="1.2.3.301"></cosmoz-treenode>
		</template>
	</test-fixture>

	<test-fixture id="lookupNodeById">
		<template>
			<cosmoz-treenode key-property="id" key-value="3a7654f1-e3e6-49c7-b6a8-a4fb00f31245"></cosmoz-treenode>
		</template>
	</test-fixture>

	<test-fixture id="multiRoot">
		<template>
			<cosmoz-treenode key-property="pathLocator" key-value="1.2.3"></cosmoz-treenode>
		</template>
	</test-fixture>

	<test-fixture id="missingAncestor">
		<template>
			<cosmoz-treenode key-property="pathLocator" key-value="1.2.3.301.401"></cosmoz-treenode>
		</template>
	</test-fixture>

	<script type="module">
	import { DefaultTree } from '@neovici/cosmoz-tree/cosmoz-default-tree';

	const treeBaseUrl = '/components/@neovici/cosmoz-tree/test/data',
		basicTreeUrl = `${ treeBaseUrl }/basicTree.json`,
		multiRootTreeUrl = `${ treeBaseUrl }/multiRootTree.json`,
		missingAncestorTreeUrl = `${ treeBaseUrl }/missingAncestorTree.json`,
		treeFromJsonUrl = async url => {
			const json = await fetch(url).then(r => r.json());
			return new DefaultTree(json);
		};
	
	suite('basic', () => {
		let basicFixture,
			basicTree;

		suiteSetup(async () => {
			basicTree = await treeFromJsonUrl(basicTreeUrl);
		});

		setup(done => {
			basicFixture = fixture('basic');
			basicFixture.ownerTree = basicTree;
			setTimeout(done);
		});

		test('instantiating the element works', () => {
			assert.equal(basicFixture.tagName, 'COSMOZ-TREENODE');
		});

		test('_computePath', () => {
			assert.equal(basicFixture._computePath(), undefined);
			assert.deepEqual(
				basicFixture._computePath(basicTree, 'id', '11111111-1111-1111-1111-111111111111'),
				basicTree.getPathNodes('1')
			);
			assert.deepEqual(
				basicFixture._computePath(basicTree, 'id', '3a7654f1-e3e6-49c7-b6a8-a4fb00f31245'),
				basicTree.getPathNodes('1.2.3')
			);
			assert.equal(basicFixture._computePath(new DefaultTree({}), 'id', '11111111-1111-1111-1111-111111111111'), null);
		});

		test('_computePathToRender', () => {
			assert.equal(basicFixture._computePathToRender(), undefined);
			assert.deepEqual(basicFixture._computePathToRender(['a', 'b', 'c', 'd'], 2), ['c', 'd']);
			assert.deepEqual(basicFixture._computePathToRender(['a', 'b', 'c', 'd'], 1), ['b', 'c', 'd']);
			assert.deepEqual(basicFixture._computePathToRender(['a', 'b', 'c', 'd'], 1, 1), ['d']);
		});

		test('renders path', () => {
			const sep = basicFixture.pathSeparator,
				textContent = basicFixture.shadowRoot.querySelector('span').textContent;
			assert.equal(textContent, ['Root', 'Node2', 'Node3', 'Node301'].join(sep));
		});

		test('uses pathSeparator', done => {
			const customSep = '#';
			basicFixture.pathSeparator = customSep;
			setTimeout(() => {
				const textContent = basicFixture.shadowRoot.querySelector('span').textContent;
				assert.equal(textContent, ['Root', 'Node2', 'Node3', 'Node301'].join(customSep));
				done();
			});
		});
	});


	suite('lookupNodeById', () => {
		let basicFixture,
			basicTree;

		suiteSetup(async () => {
			basicTree = await treeFromJsonUrl(basicTreeUrl);
		});

		setup(done => {
			basicFixture = fixture('lookupNodeById');
			basicFixture.ownerTree = basicTree;
			setTimeout(done);
		});

		test('renders path', () => {
			const sep = basicFixture.pathSeparator,
				textContent = basicFixture.shadowRoot.querySelector('span').textContent;
			assert.equal(textContent, ['Root', 'Node2', 'Node3'].join(sep));
		});

	});


	suite('multiRoot', () => {
		let multiRootFixture,
			multiRootTree;

		suiteSetup(async () => {
			multiRootTree = await treeFromJsonUrl(multiRootTreeUrl);
		});

		setup(done => {
			multiRootFixture = fixture('multiRoot');
			multiRootFixture.ownerTree = multiRootTree;
			setTimeout(done);
		});

		test('renders path', () => {
			const sep = multiRootFixture.pathSeparator,
				textContent = multiRootFixture.shadowRoot.querySelector('span').textContent;
			assert.equal(textContent, ['Node2', 'Node3'].join(sep));
		});

	});


	suite('missingAncestor', () => {
		let missingAncestorFixture,
			missingAncestorTree;

		suiteSetup(async () => {
			missingAncestorTree = await treeFromJsonUrl(missingAncestorTreeUrl);
		});

		setup(done => {
			missingAncestorFixture = fixture('missingAncestor');
			missingAncestorFixture.ownerTree = missingAncestorTree;
			setTimeout(done);
		});

		test('renders all path parts', () => {
			const sep = missingAncestorFixture.pathSeparator,
				textContent = missingAncestorFixture.shadowRoot.querySelector('span').textContent;
			assert.equal(textContent, ['Node301', 'Node401'].join(sep));
		});

	});
	</script>
</body>
</html>
